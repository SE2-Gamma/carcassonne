Index: ../core/src/main/java/at/aau/se2/gamma/core/models/impl/GameMap.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package at.aau.se2.gamma.core.models.impl;\r\n\r\nimport at.aau.se2.gamma.core.exceptions.*;\r\nimport at.aau.se2.gamma.core.factories.GameCardSideFactory;\r\n\r\nimport java.io.Serializable;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.LinkedList;\r\nimport java.util.NoSuchElementException;\r\nimport java.util.concurrent.ConcurrentLinkedDeque;\r\nimport java.util.logging.Logger;\r\n\r\npublic class GameMap implements Serializable {\r\n    // default values for the map\r\n    public final static int DEFAULT_HEIGHT = 100;\r\n    public final static int DEFAULT_WIDTH = 100;\r\n\r\n    private GameMapEntry[][] mapArray;\r\n    private ConcurrentLinkedDeque<CheatMove> cheatMoves=new ConcurrentLinkedDeque<>();\r\n    public void executeCheatMove(CheatMove cheatMove)throws CheatMoveImpossibleException{\r\n        System.out.print(\"//startin to execute cheatmove//\");\r\n        int x=cheatMove.soldier.getX();\r\n        int y=cheatMove.soldier.getY();\r\n        GameMapEntry gameMapEntry = mapArray[y][x];\r\n        //checks if a soldier is on the card\r\n        System.out.print(\"//checking if soldier is on card//\");\r\n\r\n        if(gameMapEntry == null){\r\n            throw new CheatMoveImpossibleException(\"Invalid entry\");\r\n        }\r\n\r\n        System.out.print(\"//new positiion on soldier//\");\r\n        synchronized (cheatMoves) {\r\n            //removes first soldierplacement. requires that only one soldier can be placed per gamecard\r\n            System.out.print(\"/replaces soldier placement //\");\r\n            cheatMove.soldier.soldierPlacement = null;\r\n            gameMapEntry.getSoldierPlacements().clear();\r\n            //adds new soldierplacement\r\n            gameMapEntry.setSoldier(cheatMove.soldier,cheatMove.newPosition.getGameCardSide());\r\n\r\n            cheatMoves.add(cheatMove);\r\n            cheatMove.getSoldier().getActiveCheats().add(cheatMove);\r\n        }\r\n    }\r\n    public LinkedList<CheatMove> detectCheatMove(Soldier soldier) throws  NoSuchCheatActiveException {\r\n       synchronized (cheatMoves) {\r\n           System.out.print(\"//searching soldier//\");\r\n\r\n           if(soldier.getActiveCheats().size()==0){\r\n               throw new NoSuchCheatActiveException();\r\n           }\r\n\r\n           return soldier.getActiveCheats();\r\n\r\n        }\r\n\r\n    }\r\n    public void undoCheatMove(LinkedList<CheatMove> moves){\r\n        synchronized (cheatMoves) {\r\n            for (CheatMove move:moves\r\n                 ) {\r\n                cheatMoves.remove(move);\r\n            }\r\n        }\r\n\r\n        //clears soldier placements of the gameMapEntry and sets it to the very first original position\r\n        CheatMove cheatMove = moves.getFirst();\r\n        Soldier soldier = cheatMove.getSoldier();\r\n        GameMapEntry gameMapEntry = mapArray[soldier.getY()][soldier.getX()];\r\n        soldier.soldierPlacement=null;\r\n        gameMapEntry.getSoldierPlacements().clear();\r\n\r\n        gameMapEntry.getSoldierPlacements().add(cheatMove.originalPosition);\r\n        soldier.setSoldierPlacement(cheatMove.originalPosition);\r\n\r\n\r\n        //todo: give each cheater the correct penalty (CheatMove.getPlayername <- the cheater\r\n        // CheatMove.getPenalty <- the correct number of points lost. is independent from detected cheats but number of cheats done.\r\n        // so if a player has done 4 cheats but the very first is detected he only loses 1 points, but if the last cheat is detected first he loses 2^4 points.\r\n        cheatMove.cheater.addPlayerPoints(cheatMove.penalty);\r\n    }\r\n\r\n    public GameMap() {\r\n        this(DEFAULT_HEIGHT, DEFAULT_WIDTH);\r\n    }\r\n    public GameMapHandler gameMapHandler = null;\r\n\r\n    public GameMap(int height, int width) {\r\n        mapArray = new GameMapEntry[height][width];\r\n    }\r\n\r\n    public GameMapEntry[][] getMapArray() {\r\n        return mapArray;\r\n    }\r\n\r\n    /**\r\n     * Place or replace an entry to the map array\r\n     * @param entry\r\n     * @param position\r\n     * @return boolean if it was placed or not\r\n     */\r\n    public boolean placeGameMapEntry(GameMapEntry entry, GameMapEntryPosition position) {\r\n        if (position.getY() >= 0 && position.getY() < mapArray.length\r\n        && position.getX() >= 0 && position.getX() < mapArray[0].length) {\r\n            mapArray[position.getY()][position.getX()] = entry;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * execute a game move from one player\r\n     * @param gameMove\r\n     */\r\n    public void executeGameMove(GameMove gameMove)\r\n            throws InvalidPositionGameMapException, PositionNotFreeGameMapException,\r\n            NoSurroundingCardGameMapException, SurroundingConflictGameMapException {\r\n        GameMapEntryPosition position = gameMove.getGameMapEntryPosition();\r\n        GameMapEntry entryCandidate = gameMove.getGameMapEntry();\r\n\r\n        // check if position is in gamemap\r\n        if (position.getY() >= this.mapArray.length || position.getY() < 0\r\n        || position.getX() >= this.mapArray[0].length || position.getX() < 0) {\r\n            throw new InvalidPositionGameMapException();\r\n        }\r\n\r\n        // check if position is free\r\n        if (this.mapArray[position.getY()][position.getX()] != null) {\r\n            throw new PositionNotFreeGameMapException();\r\n        }\r\n\r\n        // get surrounding fields with a 3x3 submap\r\n        GameMapEntry[] neswSurroundingFields = this.getNESWSurroundingFields(position);\r\n\r\n        // check if there are vertical or horizontal surrounding fields\r\n        boolean neighbourExist = false;\r\n        for(GameMapEntry entry: neswSurroundingFields) {\r\n            if (entry != null) {\r\n                neighbourExist = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!neighbourExist) {\r\n            throw new NoSurroundingCardGameMapException();\r\n        }\r\n\r\n        // check if new entry matches to neighbours\r\n        for(int i = 0; i < neswSurroundingFields.length; i++) {\r\n            GameMapEntry neighbour = neswSurroundingFields[i];\r\n\r\n            if (neighbour != null) {\r\n                // get orientation side where the neighbour is located\r\n                Orientation side;\r\n                switch (i) {\r\n                    case 1: side = Orientation.EAST; break;\r\n                    case 2: side = Orientation.SOUTH; break;\r\n                    case 3: side = Orientation.WEST; break;\r\n                    default: side = Orientation.NORTH;\r\n                }\r\n\r\n                System.out.println(\"side: \"+i+\" - \"+side.toString());\r\n\r\n                // if it can't connect to each other, throw error\r\n                if (!neighbour.canConnectTo(entryCandidate, side)) {\r\n                    throw new SurroundingConflictGameMapException();\r\n                }\r\n            }\r\n        }\r\n\r\n        // place the movement\r\n        this.mapArray[position.getY()][position.getX()] = entryCandidate;\r\n\r\n        // check if neighbour (diagonal, vertical and horizontal) is a monastery, if that is the case,\r\n        // check if the monastery is finished, and return an own detection data object\r\n        for(GameMapEntry[] row: get3x3SubMap(position)) {\r\n            for(GameMapEntry neighbour: row) {\r\n                if (neighbour != null\r\n                        && neighbour.getCard().getSideMid() != null\r\n                        && neighbour.getCard().getSideMid().getType() == GameCardSide.Type.MONASTERY) {\r\n                    // check monastery\r\n                    GameMapEntryPosition monasteryPosition = getPositionFromEntry(neighbour);\r\n                    if (isFieldFullyCompleted(monasteryPosition)) {\r\n                        ClosedFieldDetectionData monasteryDetectionData = new ClosedFieldDetectionData();\r\n                        monasteryDetectionData.addPoints(GameCardSideFactory.POINTS_DEFAULT*9);\r\n                        monasteryDetectionData.addGameCardSide(neighbour.getCard().getSideMid());\r\n                        monasteryDetectionData.addGameCard(neighbour.getCard());\r\n                        if (gameMapHandler != null) {\r\n                            gameMapHandler.onClosedField(monasteryDetectionData);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // check current state, and notify observer if needed\r\n        GameCardSide[] alignedSides = entryCandidate.getAlignedCardSides();\r\n        ArrayList<Integer> usedIds = new ArrayList<>();\r\n        for(int i = 0; i < alignedSides.length; i++) {\r\n            GameCardSide cardSide = alignedSides[i];\r\n\r\n            if (cardSide.isClosingSide) {\r\n\r\n                // check all connected sides to check if we have a full closed thing here\r\n                ClosedFieldDetectionData detectionData = new ClosedFieldDetectionData();\r\n                checkClosedState(i, position, detectionData, cardSide);\r\n\r\n                if(detectionData.isClosed()) {\r\n                    if (gameMapHandler != null) {\r\n                        gameMapHandler.onClosedField(detectionData);\r\n                    }\r\n                }\r\n            } else {\r\n                // check if the open side close something\r\n                // pretend this side is closed, and check if it would lead to a closed field\r\n                // repeat this step with all other sides with the same open type,\r\n                // if all pretended closed sides leads to closed fields, then these sides are closing the whole field.\r\n\r\n                // break if the field was already used in this else branch for a previous side\r\n                for(int n: usedIds) {\r\n                    if(n == i) {\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                // check if this side would close a field\r\n                ClosedFieldDetectionData detectionData = new ClosedFieldDetectionData();\r\n                checkClosedState(i, position, detectionData, cardSide);\r\n\r\n                // if this one would lead to a closed field, check the next sides on this card\r\n                if(detectionData.isClosed()) {\r\n                    ArrayList<ClosedFieldDetectionData> closedFieldDetectionDataArr = new ArrayList<>();\r\n                    ArrayList<Integer> checkedIds = new ArrayList<>();\r\n                    checkedIds.add(i);\r\n                    boolean closed = true;\r\n\r\n                    for(int j = i+1; j < alignedSides.length; j++) {\r\n                        GameCardSide subCardSide = alignedSides[j];\r\n\r\n                        // continue for different types or closing sides\r\n                        if (!subCardSide.getType().equals(cardSide.getType()) || subCardSide.isClosingSide) {\r\n                            continue;\r\n                        }\r\n\r\n                        // check if this side would close a field\r\n                        ClosedFieldDetectionData subDetectionData = new ClosedFieldDetectionData();\r\n                        checkClosedState(j, position, subDetectionData, subCardSide);\r\n\r\n                        checkedIds.add(j);\r\n\r\n                        if(subDetectionData.isClosed()) {\r\n                            closedFieldDetectionDataArr.add(subDetectionData);\r\n                            continue;\r\n                        }\r\n\r\n                        closed = false;\r\n                    }\r\n\r\n                    // add used ids\r\n                    usedIds.addAll(checkedIds);\r\n\r\n                    // side is not closed, if there are only one open side which closes the field\r\n                    if (closedFieldDetectionDataArr.size() < 1) {\r\n                        closed = false;\r\n                    }\r\n\r\n                    if (closed) {\r\n                        // reset the points to 0\r\n                        detectionData.setPoints(0);\r\n\r\n                        // add new gamecard sides with their points to detectionData\r\n                        for(ClosedFieldDetectionData dat: closedFieldDetectionDataArr) {\r\n                            for(GameCardSide newGameCardSide: dat.getGameCardSides()) {\r\n                                // if the gamecard side isn't added to the summarized detectionData\r\n                                if (!detectionData.getGameCardSides().contains(newGameCardSide)) {\r\n                                    detectionData.getGameCardSides().add(newGameCardSide);\r\n                                }\r\n                            }\r\n                            for(GameCard gameCard: dat.getGameCards()) {\r\n                                detectionData.addGameCard(gameCard);\r\n                            }\r\n                        }\r\n\r\n                        // recalculate points\r\n                        for(GameCardSide gameCardSide: detectionData.getGameCardSides()) {\r\n                            detectionData.addPoints(gameCardSide.getPoints() * gameCardSide.getMultiplier());\r\n                        }\r\n\r\n                        // notify listener\r\n                        if (gameMapHandler != null) {\r\n                            gameMapHandler.onClosedField(detectionData);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public ArrayList<ClosedFieldDetectionData> createFinalPointsDetectionData(ArrayList<Player> players) {\r\n        ArrayList<ClosedFieldDetectionData> finalDetectionData = new ArrayList<>();\r\n\r\n        // getSoldiers\r\n        ArrayList<SoldierPlacement> soldierPlacements = new ArrayList<>();\r\n        for(Player player: players) {\r\n            for(Soldier soldier: player.getSoldiers()) {\r\n                if (soldier.getSoldierPlacement() != null) {\r\n                    soldierPlacements.add(soldier.getSoldierPlacement());\r\n                }\r\n            }\r\n        }\r\n\r\n        // iterate through all fields, and check if a soldier is placed on any side\r\n        for(int y = 0; y < mapArray.length; y++) {\r\n            GameMapEntry[] row = mapArray[y];\r\n            for(int x = 0; x < row.length; x++) {\r\n                GameMapEntry entry = row[x];\r\n                // check if a card is placed\r\n                if (entry != null) {\r\n                    GameCard card = entry.getCard();\r\n                    GameCardSide[] alignedCardSides = entry.getAlignedCardSides();\r\n\r\n                    // check if a soldier is present on one card side\r\n                    for(int direction = 0; direction < alignedCardSides.length; direction++) {\r\n                        GameCardSide side = alignedCardSides[direction];\r\n                        // check if the cardSide is related to a soldierPlacement\r\n                        for(SoldierPlacement soldierPlacement: soldierPlacements) {\r\n                            if (soldierPlacement.getGameCardSide() == side) {\r\n                                GameMapEntryPosition position = new GameMapEntryPosition(x, y);\r\n                                ClosedFieldDetectionData detectionData = new ClosedFieldDetectionData();\r\n                                detectionData.setEndGameData(true);\r\n                                // calculate points for gras\r\n                                if (side.getType().equals(GameCardSide.Type.GRAS)) {\r\n                                    // get connected gras sites\r\n\r\n                                    for(int orientationToCheck = 0; orientationToCheck < alignedCardSides.length; orientationToCheck++) {\r\n                                        GameCardSide sideToCheck = alignedCardSides[orientationToCheck];\r\n                                        if (sideToCheck.getType().equals(side.getType())) {\r\n                                            // only the site with the soldier is allowed to be a closing side\r\n                                            if (!sideToCheck.isClosingSide() || sideToCheck == side) {\r\n                                                checkGrasFields(orientationToCheck, position, detectionData, sideToCheck);\r\n                                            }\r\n                                        }\r\n                                    }\r\n\r\n                                    finalDetectionData.add(detectionData);\r\n                                } else {\r\n                                    // calculate points for other unfinished sides\r\n                                    // check each open side of this type on this card\r\n                                    for(int orientationToCheck = 0; orientationToCheck < alignedCardSides.length; orientationToCheck++) {\r\n                                        GameCardSide sideToCheck = alignedCardSides[orientationToCheck];\r\n                                        if (sideToCheck.getType().equals(side.getType())) {\r\n                                            // only the site with the soldier is allowed to be a closing side\r\n                                            if (!sideToCheck.isClosingSide() || sideToCheck == side) {\r\n                                                checkClosedState(orientationToCheck, position, detectionData, sideToCheck, true);\r\n                                            }\r\n                                        }\r\n                                    }\r\n\r\n                                    finalDetectionData.add(detectionData);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // check if a soldier is set on a mandatory\r\n                    if (card.getSideMid() != null\r\n                            && card.getSideMid().getType() == GameCardSide.Type.MONASTERY) {\r\n                        GameCardSide side = card.getSideMid();\r\n                        for(SoldierPlacement soldierPlacement: soldierPlacements) {\r\n                            if (soldierPlacement.getGameCardSide() == side) {\r\n                                GameMapEntry[][] fields = get3x3SubMap(new GameMapEntryPosition(x, y));\r\n                                ClosedFieldDetectionData detectionData = new ClosedFieldDetectionData();\r\n                                detectionData.setMonasteryType(true);\r\n                                for(GameMapEntry[] fieldsRow: fields) {\r\n                                    for(GameMapEntry field: fieldsRow) {\r\n                                        if(field != null) {\r\n                                            detectionData.addPoints(1);\r\n\r\n                                            if (field.getCard().getSideMid() != null) {\r\n                                                detectionData.addGameCardSide(field.getCard().getSideMid());\r\n                                            } else {\r\n                                                detectionData.addGameCardSide(field.getCard().getSideNorth());\r\n                                            }\r\n                                            detectionData.addGameCard(field.getCard());\r\n                                        }\r\n                                    }\r\n                                }\r\n\r\n                                finalDetectionData.add(detectionData);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return finalDetectionData;\r\n    }\r\n\r\n    private void checkGrasFields(int orientation, GameMapEntryPosition position, ClosedFieldDetectionData detectionData, GameCardSide currentCardSide) {\r\n        // calculate position of neighbours card side\r\n        GameMapEntryPosition nextPosition = getNeighbourPosition(orientation, position);\r\n\r\n        // check if we have a card on this position\r\n        GameMapEntry nextMapEntry = getNeighbour(orientation, position);\r\n\r\n        detectionData.addGameCardSide(currentCardSide);\r\n        detectionData.addGameCard(mapArray[position.getY()][position.getX()].getCard());\r\n        if (nextMapEntry == null) {\r\n            detectionData.setClosed(false);\r\n            return;\r\n        }\r\n\r\n        // calculate opposite cardside\r\n        GameCardSide[] neighbourAlignedSides = nextMapEntry.getAlignedCardSides();\r\n        int oppositeOrientation = 2;\r\n        switch(orientation) {\r\n            case 1: oppositeOrientation = 3; break;\r\n            case 2: oppositeOrientation = 0; break;\r\n            case 3: oppositeOrientation = 1; break;\r\n        }\r\n        GameCardSide oppositeGameCardSide = neighbourAlignedSides[oppositeOrientation];\r\n\r\n        // add the points for the opposite side\r\n        detectionData.addGameCardSide(oppositeGameCardSide);\r\n        detectionData.addGameCard(nextMapEntry.getCard());\r\n\r\n        // if the side isn't closed, check the other open sides of this type, and the neighbours\r\n        for(int i = 0; i < neighbourAlignedSides.length; i++) {\r\n            // if the current neighbour is closed, prevent the opposite site check\r\n            if (oppositeGameCardSide.isClosingSide && Math.abs(oppositeOrientation-i) != 2) {\r\n                continue;\r\n            }\r\n\r\n            if (i != oppositeOrientation) {\r\n                GameCardSide cardSide = neighbourAlignedSides[i];\r\n                // check if the other side isn't closed (so it's connected to our side here), and if the types are the same\r\n                if (!cardSide.isClosingSide && cardSide.getType() == currentCardSide.getType()) {\r\n                    //check if cardSide is already visited before start a new check, to prevent a circle loop\r\n                    boolean alreadyVisited = false;\r\n                    for(GameCardSide cs: detectionData.getGameCardSides()) {\r\n                        if(cs == cardSide) {\r\n                            alreadyVisited = true;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if(!alreadyVisited) {\r\n                       checkGrasFields(i, nextPosition, detectionData, cardSide);\r\n                    }\r\n                } else if (cardSide.getType() == GameCardSide.Type.CASTLE) { // check if cardside is castle\r\n                    // check if card side isn't at opposite direction.\r\n                    if (Math.abs(oppositeOrientation-i) != 2) {\r\n                        ArrayList<GameCardSide> scannedCastles = detectionData.getScannedCastles();\r\n                        // check if castle was already scanned\r\n                        if (!scannedCastles.contains(cardSide)) {\r\n                            // check if castle is closed\r\n                            ClosedFieldDetectionData castleDetection = new ClosedFieldDetectionData();\r\n                            checkClosedState(i, nextPosition, castleDetection, cardSide, true);\r\n\r\n                            // add castles to visited fields\r\n                            scannedCastles.addAll(castleDetection.getGameCardSides());\r\n\r\n                            // add detection to detectionData\r\n                            if (castleDetection.isClosed()) {\r\n                                detectionData.getDetectedCastles().add(castleDetection);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the position of an entry which is present in the array. Otherwise, it returns null.\r\n     * @param entry\r\n     * @return GameMapEntryPosition: position of entry if one exists\r\n     */\r\n    private GameMapEntryPosition getPositionFromEntry(GameMapEntry entry) {\r\n        for(int y = 0; y < mapArray.length; y++) {\r\n            for(int x = 0; x < mapArray[y].length; x++) {\r\n                GameMapEntry currentEntry = mapArray[y][x];\r\n                if (currentEntry != null && currentEntry == entry) {\r\n                    return new GameMapEntryPosition(x, y);\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * check if a card is fully completed like if a monastery is complete (each 8 neighbours are set)\r\n     * @param monasteryEntryPosition\r\n     * @return\r\n     */\r\n    private boolean isFieldFullyCompleted(GameMapEntryPosition monasteryEntryPosition) {\r\n        GameMapEntry[][] submap = get3x3SubMap(monasteryEntryPosition);\r\n        for(GameMapEntry[] row: submap) {\r\n            for(GameMapEntry entry: row) {\r\n                if (entry == null) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get the position of the neighbour, which connects to the cardSide with position\r\n     * @param orientation of the cardSide\r\n     * @param position of current card in map array\r\n     * @return GameMapEntryPosition position of neighbour card\r\n     */\r\n    private GameMapEntryPosition getNeighbourPosition(int orientation, GameMapEntryPosition position) {\r\n        GameMapEntryPosition nextPosition = null;\r\n\r\n        switch(orientation) {\r\n            case 0: nextPosition = new GameMapEntryPosition(position.getX(), position.getY()+1); break;\r\n            case 1: nextPosition = new GameMapEntryPosition(position.getX()+1, position.getY()); break;\r\n            case 2: nextPosition = new GameMapEntryPosition(position.getX(), position.getY()-1); break;\r\n            case 3: nextPosition = new GameMapEntryPosition(position.getX()-1, position.getY()); break;\r\n        }\r\n\r\n        return nextPosition;\r\n    }\r\n\r\n    /**\r\n     Get the neighbour card, which connects to the cardSide with position\r\n     * @param orientation of the cardSide\r\n     * @param position of current card in map array\r\n     * @return GameMapEntry neighbour of card side if one exists, otherwise return null\r\n     */\r\n    private GameMapEntry getNeighbour(int orientation, GameMapEntryPosition position) {\r\n        GameMapEntryPosition nextPosition = getNeighbourPosition(orientation, position);\r\n\r\n        // check if position is valid\r\n        if (nextPosition == null || nextPosition.getX() < 0 || nextPosition.getX() >= mapArray.length\r\n                || nextPosition.getY() < 0 || nextPosition.getY() >= mapArray.length) {\r\n            return null;\r\n        }\r\n\r\n        // return card or null\r\n        return mapArray[nextPosition.getY()][nextPosition.getX()];\r\n    }\r\n\r\n    private void checkClosedState(int orientation, GameMapEntryPosition position, ClosedFieldDetectionData detectionData, GameCardSide currentCardSide) {\r\n        checkClosedState(orientation, position, detectionData, currentCardSide, false);\r\n    }\r\n\r\n    private void checkClosedState(int orientation, GameMapEntryPosition position, ClosedFieldDetectionData detectionData, GameCardSide currentCardSide, boolean addAlsoOpenSides) {\r\n        // calculate position of neighbour card side\r\n        GameMapEntryPosition nextPosition = getNeighbourPosition(orientation, position);\r\n\r\n        // check if we have a card on this position\r\n        GameMapEntry nextMapEntry = getNeighbour(orientation, position);\r\n        if (nextMapEntry == null) {\r\n            detectionData.setClosed(false);\r\n            if (addAlsoOpenSides) {\r\n                // add the points for this side\r\n                detectionData.addGameCardSide(currentCardSide);\r\n                detectionData.addGameCard(mapArray[position.getY()][position.getX()].getCard());\r\n                detectionData.addPoints(currentCardSide.getPoints() * currentCardSide.getMultiplier());\r\n            }\r\n            return;\r\n        }\r\n\r\n        // add the points for this side\r\n        detectionData.addGameCardSide(currentCardSide);\r\n        detectionData.addGameCard(mapArray[position.getY()][position.getX()].getCard());\r\n        detectionData.addPoints(currentCardSide.getPoints() * currentCardSide.getMultiplier());\r\n\r\n        // calculate opposite cardside\r\n        GameCardSide[] neighbourAlignedSides = nextMapEntry.getAlignedCardSides();\r\n        int oppositeOrientation = 2;\r\n        switch(orientation) {\r\n            case 1: oppositeOrientation = 3; break;\r\n            case 2: oppositeOrientation = 0; break;\r\n            case 3: oppositeOrientation = 1; break;\r\n        }\r\n        GameCardSide oppositeGameCardSide = neighbourAlignedSides[oppositeOrientation];\r\n\r\n        // add the points for the opposite side\r\n        detectionData.addGameCardSide(oppositeGameCardSide);\r\n        detectionData.addGameCard(nextMapEntry.getCard());\r\n        detectionData.addPoints(oppositeGameCardSide.getPoints() * oppositeGameCardSide.getMultiplier());\r\n\r\n        // check if it's closed\r\n        if (oppositeGameCardSide.isClosingSide) {\r\n            return;\r\n        }\r\n\r\n        // if the side isn't closed, check the other open sides of this type, and the neighbours\r\n        for(int i = 0; i < neighbourAlignedSides.length; i++) {\r\n            if (i != oppositeOrientation) {\r\n                GameCardSide cardSide = neighbourAlignedSides[i];\r\n                // check if the other side isn't closed (so it's connected to our side here), and if the types are the same\r\n                if (!cardSide.isClosingSide && cardSide.getType() == currentCardSide.getType()) {\r\n                    //check if cardSide is already visited before start a new check, to prevent a circle loop\r\n                    boolean alreadyVisited = false;\r\n                    for(GameCardSide cs: detectionData.getGameCardSides()) {\r\n                        if(cs == cardSide) {\r\n                            alreadyVisited = true;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if(!alreadyVisited) {\r\n                        checkClosedState(i, nextPosition, detectionData, cardSide, addAlsoOpenSides);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get vertical and horizontal surrounding fields in nesw order\r\n     * @param position\r\n     * @return\r\n     */\r\n    public GameMapEntry[] getNESWSurroundingFields(GameMapEntryPosition position) {\r\n        GameMapEntry[][] submap3x3 = this.get3x3SubMap(position);\r\n        GameMapEntry[] neswSurroundingFields = new GameMapEntry[4];\r\n        neswSurroundingFields[0] = submap3x3[2][1];\r\n        neswSurroundingFields[1] = submap3x3[1][2];\r\n        neswSurroundingFields[2] = submap3x3[0][1];\r\n        neswSurroundingFields[3] = submap3x3[1][0];\r\n\r\n        return neswSurroundingFields;\r\n    }\r\n\r\n    /**\r\n     * get a 3x3 submap of the whole map\r\n     * @param midPosition\r\n     * @return\r\n     */\r\n    public GameMapEntry[][] get3x3SubMap(GameMapEntryPosition midPosition) {\r\n        GameMapEntry[][] surroundingFields = new GameMapEntry[3][3];\r\n\r\n        // iterate through each field in the subarray\r\n        for (int y = -1; y < 2; y++) {\r\n            for (int x = -1; x < 2; x++) {\r\n                GameMapEntry entry = null;\r\n                int posY = midPosition.getY()+y;\r\n                int posX = midPosition.getX()+x;\r\n\r\n                if (posY >= 0 && posY < mapArray.length\r\n                && posX >= 0 && posX < mapArray[0].length) {\r\n                    entry = mapArray[posY][posX];\r\n                }\r\n\r\n                surroundingFields[y+1][x+1] = entry;\r\n            }\r\n        }\r\n        return surroundingFields;\r\n    }\r\n    //Diese Methode checkt ob es Stellen am Spielfeld gibt an denen eine Karte plaziert werden kann\r\n    public boolean checkCardPlaceability(GameCard gameCard){\r\n\r\n        GameMapEntry mapentry;\r\n        GameMapEntry[] surroundingfields;\r\n        Orientation[] orientationArr = new Orientation[4];\r\n        orientationArr[0] = Orientation.NORTH;\r\n        orientationArr[1] = Orientation.EAST;\r\n        orientationArr[2] = Orientation.SOUTH;\r\n        orientationArr[3] = Orientation.WEST;\r\n\r\n        for(int y = 0; y < mapArray.length; y++){\r\n            for (int x = 0; x < mapArray[y].length; x++){\r\n                //es werden alle positionen gefunden in denen bereits eine Karte liegt da nur an diese eine neue angefügt werden kann\r\n                //in diesen Positionen werden dann alle leeren Nachbarn überprüft ob die momemtane Karte in irgendeiner\r\n                //Orientierung hineingelegt werden kann\r\n                if(!(mapArray[y][x] == null)){\r\n\r\n                    for (Orientation orientation:orientationArr) {\r\n                        if(y< mapArray.length-1&&mapArray[y+1][x] == null){\r\n                            mapentry = new GameMapEntry(gameCard,orientation);\r\n                            surroundingfields = getNESWSurroundingFields(new GameMapEntryPosition(x,y+1));\r\n                            if(gameCardMatchesNeighbors(surroundingfields,mapentry)){\r\n                                return true;\r\n                            }\r\n                        }\r\n                        if(y>0&&mapArray[y-1][x] == null){\r\n                            mapentry = new GameMapEntry(gameCard,orientation);\r\n                            surroundingfields = getNESWSurroundingFields(new GameMapEntryPosition(x,y-1));\r\n                            if(gameCardMatchesNeighbors(surroundingfields,mapentry)){\r\n                                return true;\r\n                            }\r\n                        }\r\n                        if(x< mapArray.length-1&&mapArray[y][x+1] == null){\r\n                            mapentry = new GameMapEntry(gameCard,orientation);\r\n                            surroundingfields = getNESWSurroundingFields(new GameMapEntryPosition(x+1,y));\r\n                            if(gameCardMatchesNeighbors(surroundingfields,mapentry)){\r\n                                return true;\r\n                            }\r\n                        }\r\n                        if(x>0&&mapArray[y][x-1] == null){\r\n                            mapentry = new GameMapEntry(gameCard,orientation);\r\n                            surroundingfields = getNESWSurroundingFields(new GameMapEntryPosition(x-1,y));\r\n                            if(gameCardMatchesNeighbors(surroundingfields,mapentry)){\r\n                                return true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public GameMapHandler getGameMapHandler() {\r\n        return gameMapHandler;\r\n    }\r\n\r\n    public void setGameMapHandler(GameMapHandler gameMapHandler) {\r\n        this.gameMapHandler = gameMapHandler;\r\n    }\r\n\r\n    public boolean gameCardMatchesNeighbors(GameMapEntry[] neswSurroundingFields, GameMapEntry entryCandidate) {\r\n\r\n        for(int i = 0; i < neswSurroundingFields.length; i++) {\r\n            GameMapEntry neighbour = neswSurroundingFields[i];\r\n\r\n            if (neighbour != null) {\r\n                // get orientation side where the neighbour is located\r\n                Orientation side;\r\n                switch (i) {\r\n                    case 1: side = Orientation.EAST; break;\r\n                    case 2: side = Orientation.SOUTH; break;\r\n                    case 3: side = Orientation.WEST; break;\r\n                    default: side = Orientation.NORTH;\r\n                }\r\n\r\n                System.out.println(\"side: \"+i+\" - \"+side.toString());\r\n\r\n                // if it can't connect to each other, set false\r\n                if (!neighbour.canConnectTo(entryCandidate, side)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ../core/src/main/java/at/aau/se2/gamma/core/models/impl/GameMap.java	(revision 99011aff4cf8f0067eaead425303f37f79edae07)
+++ ../core/src/main/java/at/aau/se2/gamma/core/models/impl/GameMap.java	(date 1655064203110)
@@ -146,26 +146,8 @@
         }
 
         // check if new entry matches to neighbours
-        for(int i = 0; i < neswSurroundingFields.length; i++) {
-            GameMapEntry neighbour = neswSurroundingFields[i];
-
-            if (neighbour != null) {
-                // get orientation side where the neighbour is located
-                Orientation side;
-                switch (i) {
-                    case 1: side = Orientation.EAST; break;
-                    case 2: side = Orientation.SOUTH; break;
-                    case 3: side = Orientation.WEST; break;
-                    default: side = Orientation.NORTH;
-                }
-
-                System.out.println("side: "+i+" - "+side.toString());
-
-                // if it can't connect to each other, throw error
-                if (!neighbour.canConnectTo(entryCandidate, side)) {
-                    throw new SurroundingConflictGameMapException();
-                }
-            }
+        if (!gameCardMatchesNeighbors(neswSurroundingFields,entryCandidate)) {
+            throw new SurroundingConflictGameMapException();
         }
 
         // place the movement
@@ -670,7 +652,7 @@
                 //es werden alle positionen gefunden in denen bereits eine Karte liegt da nur an diese eine neue angefügt werden kann
                 //in diesen Positionen werden dann alle leeren Nachbarn überprüft ob die momemtane Karte in irgendeiner
                 //Orientierung hineingelegt werden kann
-                if(!(mapArray[y][x] == null)){
+                if((mapArray[y][x] != null)){
 
                     for (Orientation orientation:orientationArr) {
                         if(y< mapArray.length-1&&mapArray[y+1][x] == null){
Index: ../core/src/main/java/at/aau/se2/gamma/core/utils/GlobalVariables.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package at.aau.se2.gamma.core.utils;\r\n\r\npublic class GlobalVariables {\r\n    public static String getAdress() {\r\n        return adress;\r\n    }\r\n\r\n\r\n    public static void setAdress(String adress) {\r\n        GlobalVariables.adress = adress;\r\n    }\r\n\r\n    static String adress=\"172.19.192.1\";\r\n\r\n\r\n    public static String getDefaultname() {\r\n        return defaultname;\r\n    }\r\n\r\n    private static String defaultname=\"XXXXXXXXXXXX\";\r\n    private static int port=53212;\r\n    private static String defaultID=\"-1\";\r\n    public static String getDefaultID() {\r\n        return defaultID;\r\n    }\r\n\r\n    public static int getPort() {\r\n        return port;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ../core/src/main/java/at/aau/se2/gamma/core/utils/GlobalVariables.java	(revision 99011aff4cf8f0067eaead425303f37f79edae07)
+++ ../core/src/main/java/at/aau/se2/gamma/core/utils/GlobalVariables.java	(date 1655062923843)
@@ -10,7 +10,7 @@
         GlobalVariables.adress = adress;
     }
 
-    static String adress="172.19.192.1";
+    static String adress="192.168.178.31";
 
 
     public static String getDefaultname() {
Index: ../android/.idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"DesignSurface\">\r\n    <option name=\"filePathToZoomLevelMap\">\r\n      <map>\r\n        <entry key=\"..\\:/Users/phili/AndroidStudioProjects/Einzelbeispiel2/carcassonne/android/app/src/main/res/layout/activity_create_session.xml\" value=\"0.22760416666666666\" />\r\n        <entry key=\"..\\:/Users/phili/AndroidStudioProjects/Einzelbeispiel2/carcassonne/android/app/src/main/res/layout/activity_game_result.xml\" value=\"0.18541666666666667\" />\r\n        <entry key=\"..\\:/Users/phili/AndroidStudioProjects/Einzelbeispiel2/carcassonne/android/app/src/main/res/layout/activity_game_result2.xml\" value=\"0.22\" />\r\n        <entry key=\"..\\:/Users/phili/AndroidStudioProjects/Einzelbeispiel2/carcassonne/android/app/src/main/res/layout/activity_join_session.xml\" value=\"0.33\" />\r\n        <entry key=\"..\\:/Users/phili/AndroidStudioProjects/Einzelbeispiel2/carcassonne/android/app/src/main/res/layout/activity_lobby.xml\" value=\"0.25\" />\r\n        <entry key=\"..\\:/Users/phili/AndroidStudioProjects/Einzelbeispiel2/carcassonne/android/app/src/main/res/layout/activity_main.xml\" value=\"0.5\" />\r\n        <entry key=\"..\\:/Users/phili/AndroidStudioProjects/Einzelbeispiel2/carcassonne/android/app/src/main/res/layout/activity_select_name.xml\" value=\"0.33\" />\r\n        <entry key=\"..\\:/Users/phili/StudioProjects/carcassonne/android/app/src/main/res/layout/activity_game_result2.xml\" value=\"0.4765625\" />\r\n        <entry key=\"..\\:/Users/phili/StudioProjects/carcassonne/android/app/src/main/res/layout/activity_lobby.xml\" value=\"0.2864583333333333\" />\r\n        <entry key=\"..\\:/Users/phili/StudioProjects/carcassonne/android/app/src/main/res/layout/activity_main.xml\" value=\"0.2864583333333333\" />\r\n        <entry key=\"..\\:/Users/phili/StudioProjects/carcassonne/android/app/src/main/res/layout/item_lobby_player_display_cardview.xml\" value=\"0.23854166666666668\" />\r\n        <entry key=\"app/src/main/res/drawable/rounded_corner.xml\" value=\"0.1395\" />\r\n        <entry key=\"app/src/main/res/layout/activity_create_session.xml\" value=\"0.2359375\" />\r\n        <entry key=\"app/src/main/res/layout/activity_join_session.xml\" value=\"0.221875\" />\r\n        <entry key=\"app/src/main/res/layout/activity_lobby.xml\" value=\"0.2359375\" />\r\n        <entry key=\"app/src/main/res/layout/activity_main.xml\" value=\"0.33\" />\r\n        <entry key=\"app/src/main/res/layout/activity_select_name.xml\" value=\"0.1\" />\r\n        <entry key=\"app/src/main/res/layout/item_lobby_player_display_cardview.xml\" value=\"0.1\" />\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"ExternalStorageConfigurationManager\" enabled=\"true\" />\r\n  <component name=\"FrameworkDetectionExcludesConfiguration\">\r\n    <file type=\"web\" url=\"file://$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_17\" default=\"true\" project-jdk-name=\"openjdk-17\" project-jdk-type=\"JavaSDK\">\r\n    <output url=\"file://$PROJECT_DIR$/out\" />\r\n  </component>\r\n  <component name=\"SwUserDefinedSpecifications\">\r\n    <option name=\"specTypeByUrl\">\r\n      <map />\r\n    </option>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ../android/.idea/misc.xml	(revision 99011aff4cf8f0067eaead425303f37f79edae07)
+++ ../android/.idea/misc.xml	(date 1655116832393)
@@ -28,7 +28,7 @@
   <component name="FrameworkDetectionExcludesConfiguration">
     <file type="web" url="file://$PROJECT_DIR$" />
   </component>
-  <component name="ProjectRootManager" version="2" languageLevel="JDK_17" default="true" project-jdk-name="openjdk-17" project-jdk-type="JavaSDK">
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_16" project-jdk-name="openjdk-17" project-jdk-type="JavaSDK">
     <output url="file://$PROJECT_DIR$/out" />
   </component>
   <component name="SwUserDefinedSpecifications">
